package com.viplearner.api.services

import com.viplearner.api.client.BaseApiClient
import io.ktor.client.*
import io.ktor.client.engine.mock.*
import io.ktor.client.plugins.contentnegotiation.*
import io.ktor.http.*
import io.ktor.serialization.kotlinx.json.*
import io.ktor.utils.io.*
import kotlinx.coroutines.test.runTest
import kotlinx.serialization.json.Json
import kotlin.test.*

/**
 * Generated test file for BroadcastsService
 *
 * This file was automatically generated by the test generator script.
 * It contains tests for all API endpoints in the BroadcastsService service.
 *
 * Tests use MockEngine to simulate HTTP responses and verify requests.
 */
class BroadcastsServiceTest {
    @BeforeTest
    fun setup() {
        // Setup will be customized per test with mock engine
    }

    @Test
    fun testBroadcastsofficial() =
        runTest {
            // Arrange - Mock HTTP response
            val mockResponse =
                """
                {
                            "tour": {
                                        "id": "dkGBWEoa",
                                        "name": "Knight Invitational",
                                        "slug": "knight-invitational",
                                        "info": {},
                                        "createdAt": 1760452031769,
                                        "url": "https://lichess.org/broadcast/knight-invitational/dkGBWEoa",
                                        "tier": 5,
                                        "dates": [
                                                    1760452032087
                                        ]
                            },
                            "rounds": [
                                        {
                                                    "id": "KpayT1YZ",
                                                    "name": "Round 1",
                                                    "slug": "round-1",
                                                    "createdAt": 1760452031888,
                                                    "rated": false,
                                                    "ongoing": true,
                                                    "startsAt": 1760455631824,
                                                    "url": "https://lichess.org/broadcast/knight-invitational/round-1/KpayT1YZ"
                                        },
                                        {
                                                    "id": "JmMB52Fd",
                                                    "name": "Round 2",
                                                    "slug": "round-2",
                                                    "createdAt": 1760452032027,
                                                    "rated": false,
                                                    "ongoing": true,
                                                    "startsAt": 1760459231824,
                                                    "url": "https://lichess.org/broadcast/knight-invitational/round-2/JmMB52Fd"
                                        },
                                        {
                                                    "id": "iMXP05Cu",
                                                    "name": "Round 3",
                                                    "slug": "round-3",
                                                    "createdAt": 1760452032058,
                                                    "rated": false,
                                                    "ongoing": true,
                                                    "startsAt": 1760462831824,
                                                    "url": "https://lichess.org/broadcast/knight-invitational/round-3/iMXP05Cu"
                                        },
                                        {
                                                    "id": "UpDXGrhz",
                                                    "name": "Final Round",
                                                    "slug": "final-round",
                                                    "createdAt": 1760452032086,
                                                    "rated": false,
                                                    "ongoing": true,
                                                    "startsAt": 1760452032087,
                                                    "url": "https://lichess.org/broadcast/knight-invitational/final-round/UpDXGrhz"
                                        }
                            ],
                            "defaultRoundId": "KpayT1YZ"
                }
                """.trimIndent()

            val mockEngine =
                MockEngine { request ->
                    // Verify request matches expected endpoint: GET api/broadcast
                    assertEquals("api/broadcast", request.url.encodedPath.trimStart('/'))
                    assertEquals(HttpMethod.parse("GET"), request.method)

                    respond(
                        content = ByteReadChannel(mockResponse),
                        status = HttpStatusCode.fromValue(200),
                        headers = headersOf(HttpHeaders.ContentType, "application/x-ndjson"),
                    )
                }

            // Create mock HttpClient with proper configuration
            val mockHttpClient =
                HttpClient(mockEngine) {
                    install(ContentNegotiation) {
                        json(
                            Json {
                                ignoreUnknownKeys = true
                                coerceInputValues = true
                                explicitNulls = false
                            },
                        )
                    }
                }

            // Create service with mocked client
            val testApiClient =
                BaseApiClient(
                    baseUrl = "https://lichess.org",
                    token = "test_token",
                    httpClient = mockHttpClient,
                )
            val testService = BroadcastsService(testApiClient)

            // Act
            val result = testService.broadcastsOfficial()

            // Assert
            assertTrue(result.isSuccess, "API call should succeed")
            val response = result.getOrNull()
            assertNotNull(response, "Response should not be null")
            // Verify field: tour
            // Verify field: rounds
            // Verify field: defaultRoundId

            // Cleanup
            testApiClient.close()
        }

    @Test
    fun testBroadcaststop() =
        runTest {
            // Arrange - Mock HTTP response
            val mockResponse =
                """
                {
                            "active": [
                                        {
                                                    "tour": {
                                                                "id": "dkGBWEoa",
                                                                "name": "Knight Invitational",
                                                                "slug": "knight-invitational",
                                                                "info": {},
                                                                "createdAt": 1760452031769,
                                                                "url": "https://lichess.org/broadcast/knight-invitational/dkGBWEoa",
                                                                "tier": 5,
                                                                "dates": [
                                                                            1760452032087
                                                                ]
                                                    },
                                                    "round": {
                                                                "id": "KpayT1YZ",
                                                                "name": "Round 1",
                                                                "slug": "round-1",
                                                                "createdAt": 1760452031888,
                                                                "rated": false,
                                                                "ongoing": true,
                                                                "startsAt": 1760455631824,
                                                                "url": "https://lichess.org/broadcast/knight-invitational/round-1/KpayT1YZ"
                                                    }
                                        }
                            ],
                            "upcoming": [],
                            "past": {
                                        "currentPage": 1,
                                        "maxPerPage": 24,
                                        "currentPageResults": [],
                                        "previousPage": null,
                                        "nextPage": null
                            }
                }
                """.trimIndent()

            val mockEngine =
                MockEngine { request ->
                    // Verify request matches expected endpoint: GET api/broadcast/top
                    assertEquals("api/broadcast/top", request.url.encodedPath.trimStart('/'))
                    assertEquals(HttpMethod.parse("GET"), request.method)

                    respond(
                        content = ByteReadChannel(mockResponse),
                        status = HttpStatusCode.fromValue(200),
                        headers = headersOf(HttpHeaders.ContentType, "application/json"),
                    )
                }

            // Create mock HttpClient with proper configuration
            val mockHttpClient =
                HttpClient(mockEngine) {
                    install(ContentNegotiation) {
                        json(
                            Json {
                                ignoreUnknownKeys = true
                                coerceInputValues = true
                                explicitNulls = false
                            },
                        )
                    }
                }

            // Create service with mocked client
            val testApiClient =
                BaseApiClient(
                    baseUrl = "https://lichess.org",
                    token = "test_token",
                    httpClient = mockHttpClient,
                )
            val testService = BroadcastsService(testApiClient)

            // Act
            val result = testService.broadcastsTop()

            // Assert
            assertTrue(result.isSuccess, "API call should succeed")
            val response = result.getOrNull()
            assertNotNull(response, "Response should not be null")
            // Verify field: active
            // Verify field: upcoming
            // Verify field: past

            // Cleanup
            testApiClient.close()
        }

    @Test
    fun testBroadcastsbyuser() =
        runTest {
            val username = "mock"
            // Arrange - Mock HTTP response
            val mockResponse =
                """
                {
                            "currentPage": 1,
                            "maxPerPage": 24,
                            "currentPageResults": [
                                        {
                                                    "tour": {
                                                                "id": "SSCQsHi5",
                                                                "name": "Bobby's Tournament",
                                                                "slug": "bobbys-tournament",
                                                                "info": {
                                                                            "format": "5-round Swiss",
                                                                            "location": "Chess Club"
                                                                },
                                                                "createdAt": 1760452032543,
                                                                "url": "https://lichess.org/broadcast/bobbys-tournament/SSCQsHi5",
                                                                "communityOwner": {
                                                                            "name": "Bobby",
                                                                            "flair": "food-drink.cooked-rice",
                                                                            "id": "bobby"
                                                                }
                                                    }
                                        }
                            ],
                            "previousPage": null,
                            "nextPage": null,
                            "nbResults": 1,
                            "nbPages": 1
                }
                """.trimIndent()

            val mockEngine =
                MockEngine { request ->
                    // Verify request matches expected endpoint: GET api/broadcast/by/${username}
                    assertEquals("api/broadcast/by/$username", request.url.encodedPath.trimStart('/'))
                    assertEquals(HttpMethod.parse("GET"), request.method)

                    respond(
                        content = ByteReadChannel(mockResponse),
                        status = HttpStatusCode.fromValue(200),
                        headers = headersOf(HttpHeaders.ContentType, "application/json"),
                    )
                }

            // Create mock HttpClient with proper configuration
            val mockHttpClient =
                HttpClient(mockEngine) {
                    install(ContentNegotiation) {
                        json(
                            Json {
                                ignoreUnknownKeys = true
                                coerceInputValues = true
                                explicitNulls = false
                            },
                        )
                    }
                }

            // Create service with mocked client
            val testApiClient =
                BaseApiClient(
                    baseUrl = "https://lichess.org",
                    token = "test_token",
                    httpClient = mockHttpClient,
                )
            val testService = BroadcastsService(testApiClient)

            // Act
            val result = testService.broadcastsByUser(username = "mock")

            // Assert
            assertTrue(result.isSuccess, "API call should succeed")
            val response = result.getOrNull()
            assertNotNull(response, "Response should not be null")
            // Verify field: currentPage
            // Verify field: maxPerPage
            // Verify field: currentPageResults

            // Cleanup
            testApiClient.close()
        }

    @Test
    fun testBroadcastssearch() =
        runTest {
            // Arrange - Mock HTTP response
            val mockResponse =
                """
                {
                            "currentPage": 1,
                            "maxPerPage": 24,
                            "currentPageResults": [
                                        {
                                                    "tour": {
                                                                "id": "dkGBWEoa",
                                                                "name": "Knight Invitational",
                                                                "slug": "knight-invitational",
                                                                "info": {},
                                                                "createdAt": 1760452031769,
                                                                "url": "https://lichess.org/broadcast/knight-invitational/dkGBWEoa",
                                                                "tier": 5,
                                                                "dates": [
                                                                            1760452032087
                                                                ]
                                                    },
                                                    "round": {
                                                                "id": "UpDXGrhz",
                                                                "name": "Final Round",
                                                                "slug": "final-round",
                                                                "createdAt": 1760452032086,
                                                                "rated": false,
                                                                "ongoing": true,
                                                                "startsAt": 1760452032087,
                                                                "url": "https://lichess.org/broadcast/knight-invitational/final-round/UpDXGrhz"
                                                    }
                                        }
                            ],
                            "previousPage": null,
                            "nextPage": null
                }
                """.trimIndent()

            val mockEngine =
                MockEngine { request ->
                    // Verify request matches expected endpoint: GET api/broadcast/search
                    assertEquals("api/broadcast/search", request.url.encodedPath.trimStart('/'))
                    assertEquals(HttpMethod.parse("GET"), request.method)

                    respond(
                        content = ByteReadChannel(mockResponse),
                        status = HttpStatusCode.fromValue(200),
                        headers = headersOf(HttpHeaders.ContentType, "application/json"),
                    )
                }

            // Create mock HttpClient with proper configuration
            val mockHttpClient =
                HttpClient(mockEngine) {
                    install(ContentNegotiation) {
                        json(
                            Json {
                                ignoreUnknownKeys = true
                                coerceInputValues = true
                                explicitNulls = false
                            },
                        )
                    }
                }

            // Create service with mocked client
            val testApiClient =
                BaseApiClient(
                    baseUrl = "https://lichess.org",
                    token = "test_token",
                    httpClient = mockHttpClient,
                )
            val testService = BroadcastsService(testApiClient)

            // Act
            val result = testService.broadcastsSearch()

            // Assert
            assertTrue(result.isSuccess, "API call should succeed")
            val response = result.getOrNull()
            assertNotNull(response, "Response should not be null")
            // Verify field: currentPage
            // Verify field: maxPerPage
            // Verify field: currentPageResults

            // Cleanup
            testApiClient.close()
        }

    @Test
    fun testBroadcasttourcreate() =
        runTest {
            // Arrange - Mock HTTP response
            val mockResponse =
                """
                {
                            "tour": {
                                        "id": "dkGBWEoa",
                                        "name": "Knight Invitational",
                                        "slug": "knight-invitational",
                                        "info": {},
                                        "createdAt": 1760452031769,
                                        "url": "https://lichess.org/broadcast/knight-invitational/dkGBWEoa",
                                        "tier": 5
                            },
                            "rounds": []
                }
                """.trimIndent()

            val mockEngine =
                MockEngine { request ->
                    // Verify request matches expected endpoint: POST broadcast/new
                    assertEquals("broadcast/new", request.url.encodedPath.trimStart('/'))
                    assertEquals(HttpMethod.parse("POST"), request.method)

                    respond(
                        content = ByteReadChannel(mockResponse),
                        status = HttpStatusCode.fromValue(200),
                        headers = headersOf(HttpHeaders.ContentType, "application/json"),
                    )
                }

            // Create mock HttpClient with proper configuration
            val mockHttpClient =
                HttpClient(mockEngine) {
                    install(ContentNegotiation) {
                        json(
                            Json {
                                ignoreUnknownKeys = true
                                coerceInputValues = true
                                explicitNulls = false
                            },
                        )
                    }
                }

            // Create service with mocked client
            val testApiClient =
                BaseApiClient(
                    baseUrl = "https://lichess.org",
                    token = "test_token",
                    httpClient = mockHttpClient,
                )
            val testService = BroadcastsService(testApiClient)

            // Act
            val result = testService.broadcastTourCreate(formData = emptyMap())

            // Assert
            assertTrue(result.isSuccess, "API call should succeed")
            val response = result.getOrNull()
            assertNotNull(response, "Response should not be null")
            // Verify field: tour
            // Verify field: rounds

            // Cleanup
            testApiClient.close()
        }

    @Test
    fun testBroadcasttourget() =
        runTest {
            val broadcastTournamentId = "mock"
            // Arrange - Mock HTTP response
            val mockResponse =
                """
                {
                            "tour": {
                                        "id": "dkGBWEoa",
                                        "name": "Knight Invitational",
                                        "slug": "knight-invitational",
                                        "info": {},
                                        "createdAt": 1760452031769,
                                        "url": "https://lichess.org/broadcast/knight-invitational/dkGBWEoa",
                                        "tier": 5,
                                        "dates": [
                                                    1760452032087
                                        ]
                            },
                            "rounds": [
                                        {
                                                    "id": "KpayT1YZ",
                                                    "name": "Round 1",
                                                    "slug": "round-1",
                                                    "createdAt": 1760452031888,
                                                    "rated": false,
                                                    "ongoing": true,
                                                    "startsAt": 1760455631824,
                                                    "url": "https://lichess.org/broadcast/knight-invitational/round-1/KpayT1YZ"
                                        },
                                        {
                                                    "id": "JmMB52Fd",
                                                    "name": "Round 2",
                                                    "slug": "round-2",
                                                    "createdAt": 1760452032027,
                                                    "rated": false,
                                                    "ongoing": true,
                                                    "startsAt": 1760459231824,
                                                    "url": "https://lichess.org/broadcast/knight-invitational/round-2/JmMB52Fd"
                                        },
                                        {
                                                    "id": "iMXP05Cu",
                                                    "name": "Round 3",
                                                    "slug": "round-3",
                                                    "createdAt": 1760452032058,
                                                    "rated": false,
                                                    "ongoing": true,
                                                    "startsAt": 1760462831824,
                                                    "url": "https://lichess.org/broadcast/knight-invitational/round-3/iMXP05Cu"
                                        },
                                        {
                                                    "id": "UpDXGrhz",
                                                    "name": "Final Round",
                                                    "slug": "final-round",
                                                    "createdAt": 1760452032086,
                                                    "rated": false,
                                                    "ongoing": true,
                                                    "startsAt": 1760452032087,
                                                    "url": "https://lichess.org/broadcast/knight-invitational/final-round/UpDXGrhz"
                                        }
                            ],
                            "defaultRoundId": "KpayT1YZ"
                }
                """.trimIndent()

            val mockEngine =
                MockEngine { request ->
                    // Verify request matches expected endpoint: GET api/broadcast/${broadcastTournamentId}
                    assertEquals("api/broadcast/$broadcastTournamentId", request.url.encodedPath.trimStart('/'))
                    assertEquals(HttpMethod.parse("GET"), request.method)

                    respond(
                        content = ByteReadChannel(mockResponse),
                        status = HttpStatusCode.fromValue(200),
                        headers = headersOf(HttpHeaders.ContentType, "application/json"),
                    )
                }

            // Create mock HttpClient with proper configuration
            val mockHttpClient =
                HttpClient(mockEngine) {
                    install(ContentNegotiation) {
                        json(
                            Json {
                                ignoreUnknownKeys = true
                                coerceInputValues = true
                                explicitNulls = false
                            },
                        )
                    }
                }

            // Create service with mocked client
            val testApiClient =
                BaseApiClient(
                    baseUrl = "https://lichess.org",
                    token = "test_token",
                    httpClient = mockHttpClient,
                )
            val testService = BroadcastsService(testApiClient)

            // Act
            val result = testService.broadcastTourGet(broadcastTournamentId = "mock")

            // Assert
            assertTrue(result.isSuccess, "API call should succeed")
            val response = result.getOrNull()
            assertNotNull(response, "Response should not be null")
            // Verify field: tour
            // Verify field: rounds
            // Verify field: defaultRoundId

            // Cleanup
            testApiClient.close()
        }

    @Test
    fun testBroadcastplayersget() =
        runTest {
            val broadcastTournamentId = "mock"
            // Arrange - Mock HTTP response
            val mockResponse =
                """
                [
                            {
                                        "name": "Player 1",
                                        "played": 0
                            },
                            {
                                        "name": "Player 2",
                                        "played": 0
                            },
                            {
                                        "name": "Player 3",
                                        "played": 0
                            },
                            {
                                        "name": "Player 4",
                                        "played": 0
                            }
                ]
                """.trimIndent()

            val mockEngine =
                MockEngine { request ->
                    // Verify request matches expected endpoint: GET broadcast/${broadcastTournamentId}/players
                    assertEquals("broadcast/$broadcastTournamentId/players", request.url.encodedPath.trimStart('/'))
                    assertEquals(HttpMethod.parse("GET"), request.method)

                    respond(
                        content = ByteReadChannel(mockResponse),
                        status = HttpStatusCode.fromValue(200),
                        headers = headersOf(HttpHeaders.ContentType, "application/json"),
                    )
                }

            // Create mock HttpClient with proper configuration
            val mockHttpClient =
                HttpClient(mockEngine) {
                    install(ContentNegotiation) {
                        json(
                            Json {
                                ignoreUnknownKeys = true
                                coerceInputValues = true
                                explicitNulls = false
                            },
                        )
                    }
                }

            // Create service with mocked client
            val testApiClient =
                BaseApiClient(
                    baseUrl = "https://lichess.org",
                    token = "test_token",
                    httpClient = mockHttpClient,
                )
            val testService = BroadcastsService(testApiClient)

            // Act
            val result = testService.broadcastPlayersGet(broadcastTournamentId = "mock")

            // Assert
            assertTrue(result.isSuccess, "API call should succeed")
            val response = result.getOrNull()
            assertNotNull(response, "Response should not be null")
            // Add specific field assertions here

            // Cleanup
            testApiClient.close()
        }

    @Test
    fun testBroadcastplayerget() =
        runTest {
            val broadcastTournamentId = "mock"
            val playerId = "mock"
            // Arrange - Mock HTTP response
            val mockResponse =
                """
                {
                            "name": "Praggnanandhaa R",
                            "title": "GM",
                            "rating": 2758,
                            "fideId": 25059530,
                            "fed": "IND",
                            "played": 9,
                            "score": 5.5,
                            "ratingDiff": 6,
                            "performance": 2802,
                            "tiebreaks": [
                                        {
                                                    "extendedCode": "DE",
                                                    "description": "Direct encounter",
                                                    "points": 2
                                        },
                                        {
                                                    "extendedCode": "SB",
                                                    "description": "Sonneborn-Berger",
                                                    "points": 25.25
                                        },
                                        {
                                                    "extendedCode": "WON",
                                                    "description": "Number of Wins",
                                                    "points": 4
                                        },
                                        {
                                                    "extendedCode": "BWG",
                                                    "description": "Number of wins with black",
                                                    "points": 1
                                        },
                                        {
                                                    "extendedCode": "KS",
                                                    "description": "Koya system (limit 50% of score)",
                                                    "points": 3.5
                                        }
                            ],
                            "rank": 1,
                            "fide": {
                                        "ratings": {
                                                    "standard": 2785,
                                                    "rapid": 2691,
                                                    "blitz": 2707
                                        },
                                        "year": 2005
                            },
                            "games": [
                                        {
                                                    "round": "JTpOdyxT",
                                                    "id": "RLVorwj5",
                                                    "opponent": {
                                                                "name": "Erigaisi Arjun",
                                                                "title": "GM",
                                                                "rating": 2782,
                                                                "fideId": 35009192,
                                                                "fed": "IND"
                                                    },
                                                    "color": "white",
                                                    "points": "1",
                                                    "ratingDiff": 5
                                        },
                                        {
                                                    "round": "F7Ytc5UF",
                                                    "id": "TBEiFey0",
                                                    "opponent": {
                                                                "name": "Abdusattorov, Nodirbek",
                                                                "title": "GM",
                                                                "rating": 2771,
                                                                "fideId": 14204118,
                                                                "fed": "UZB"
                                                    },
                                                    "color": "black",
                                                    "points": "1",
                                                    "ratingDiff": 5
                                        }
                            ]
                }
                """.trimIndent()

            val mockEngine =
                MockEngine { request ->
                    // Verify request matches expected endpoint: GET broadcast/${broadcastTournamentId}/players/${playerId}
                    assertEquals(
                        "broadcast/$broadcastTournamentId/players/$playerId",
                        request.url.encodedPath.trimStart('/'),
                    )
                    assertEquals(HttpMethod.parse("GET"), request.method)

                    respond(
                        content = ByteReadChannel(mockResponse),
                        status = HttpStatusCode.fromValue(200),
                        headers = headersOf(HttpHeaders.ContentType, "application/json"),
                    )
                }

            // Create mock HttpClient with proper configuration
            val mockHttpClient =
                HttpClient(mockEngine) {
                    install(ContentNegotiation) {
                        json(
                            Json {
                                ignoreUnknownKeys = true
                                coerceInputValues = true
                                explicitNulls = false
                            },
                        )
                    }
                }

            // Create service with mocked client
            val testApiClient =
                BaseApiClient(
                    baseUrl = "https://lichess.org",
                    token = "test_token",
                    httpClient = mockHttpClient,
                )
            val testService = BroadcastsService(testApiClient)

            // Act
            val result = testService.broadcastPlayerGet(broadcastTournamentId = "mock", playerId = "mock")

            // Assert
            assertTrue(result.isSuccess, "API call should succeed")
            val response = result.getOrNull()
            assertNotNull(response, "Response should not be null")
            // Verify field: name
            // Verify field: title
            // Verify field: rating

            // Cleanup
            testApiClient.close()
        }

    @Test
    fun testBroadcasttourupdate() =
        runTest {
            val broadcastTournamentId = "mock"
            // Arrange - Mock HTTP response
            val mockResponse =
                """
                {
                            "ok": true
                }
                """.trimIndent()

            val mockEngine =
                MockEngine { request ->
                    // Verify request matches expected endpoint: POST broadcast/${broadcastTournamentId}/edit
                    assertEquals("broadcast/$broadcastTournamentId/edit", request.url.encodedPath.trimStart('/'))
                    assertEquals(HttpMethod.parse("POST"), request.method)

                    respond(
                        content = ByteReadChannel(mockResponse),
                        status = HttpStatusCode.fromValue(200),
                        headers = headersOf(HttpHeaders.ContentType, "application/json"),
                    )
                }

            // Create mock HttpClient with proper configuration
            val mockHttpClient =
                HttpClient(mockEngine) {
                    install(ContentNegotiation) {
                        json(
                            Json {
                                ignoreUnknownKeys = true
                                coerceInputValues = true
                                explicitNulls = false
                            },
                        )
                    }
                }

            // Create service with mocked client
            val testApiClient =
                BaseApiClient(
                    baseUrl = "https://lichess.org",
                    token = "test_token",
                    httpClient = mockHttpClient,
                )
            val testService = BroadcastsService(testApiClient)

            // Act
            val result = testService.broadcastTourUpdate(broadcastTournamentId = "mock", formData = emptyMap())

            // Assert
            assertTrue(result.isSuccess, "API call should succeed")
            val response = result.getOrNull()
            assertNotNull(response, "Response should not be null")
            // Verify field: ok

            // Cleanup
            testApiClient.close()
        }

    @Test
    fun testBroadcastroundcreate() =
        runTest {
            val broadcastTournamentId = "mock"
            // Arrange - Mock HTTP response
            val mockResponse =
                """
                {
                            "round": {
                                        "id": "UpDXGrhz",
                                        "name": "Final Round",
                                        "slug": "final-round",
                                        "createdAt": 1760452032086,
                                        "rated": false,
                                        "ongoing": true,
                                        "startsAt": 1760452032087,
                                        "url": "https://lichess.org/broadcast/knight-invitational/final-round/UpDXGrhz"
                            },
                            "tour": {
                                        "id": "dkGBWEoa",
                                        "name": "Knight Invitational",
                                        "slug": "knight-invitational",
                                        "info": {},
                                        "createdAt": 1760452031769,
                                        "url": "https://lichess.org/broadcast/knight-invitational/dkGBWEoa",
                                        "tier": 5,
                                        "dates": [
                                                    1760455631824
                                        ]
                            },
                            "study": {
                                        "writeable": true,
                                        "features": {
                                                    "chat": true,
                                                    "computer": true,
                                                    "explorer": true
                                        }
                            }
                }
                """.trimIndent()

            val mockEngine =
                MockEngine { request ->
                    // Verify request matches expected endpoint: POST broadcast/${broadcastTournamentId}/new
                    assertEquals("broadcast/$broadcastTournamentId/new", request.url.encodedPath.trimStart('/'))
                    assertEquals(HttpMethod.parse("POST"), request.method)

                    respond(
                        content = ByteReadChannel(mockResponse),
                        status = HttpStatusCode.fromValue(200),
                        headers = headersOf(HttpHeaders.ContentType, "application/json"),
                    )
                }

            // Create mock HttpClient with proper configuration
            val mockHttpClient =
                HttpClient(mockEngine) {
                    install(ContentNegotiation) {
                        json(
                            Json {
                                ignoreUnknownKeys = true
                                coerceInputValues = true
                                explicitNulls = false
                            },
                        )
                    }
                }

            // Create service with mocked client
            val testApiClient =
                BaseApiClient(
                    baseUrl = "https://lichess.org",
                    token = "test_token",
                    httpClient = mockHttpClient,
                )
            val testService = BroadcastsService(testApiClient)

            // Act
            val result = testService.broadcastRoundCreate(broadcastTournamentId = "mock", formData = emptyMap())

            // Assert
            assertTrue(result.isSuccess, "API call should succeed")
            val response = result.getOrNull()
            assertNotNull(response, "Response should not be null")
            // Verify field: round
            // Verify field: tour
            // Verify field: study

            // Cleanup
            testApiClient.close()
        }

    @Test
    fun testBroadcastroundgetNotImplemented() {
        // TODO: No examples found in OpenAPI spec for this endpoint
        // Endpoint: GET api/broadcast/${broadcastTournamentSlug}/${broadcastRoundSlug}/${broadcastRoundId}
        // Service method: BroadcastsService.broadcastRoundGet()
        // This test is skipped until examples are available in the OpenAPI specification
    }

    @Test
    fun testBroadcastroundupdate() =
        runTest {
            val broadcastRoundId = "mock"
            // Arrange - Mock HTTP response
            val mockResponse =
                """
                {
                            "round": {
                                        "id": "UpDXGrhz",
                                        "name": "Final Round 2",
                                        "slug": "final-round-2",
                                        "createdAt": 1760452032086,
                                        "rated": false,
                                        "ongoing": true,
                                        "startsAt": 1760452032087,
                                        "url": "https://lichess.org/broadcast/knight-invitational-2/final-round-2/UpDXGrhz"
                            },
                            "tour": {
                                        "id": "dkGBWEoa",
                                        "name": "Knight Invitational 2",
                                        "slug": "knight-invitational-2",
                                        "info": {},
                                        "createdAt": 1760452031769,
                                        "url": "https://lichess.org/broadcast/knight-invitational-2/dkGBWEoa",
                                        "dates": [
                                                    1760452032087
                                        ]
                            },
                            "study": {
                                        "writeable": true,
                                        "features": {
                                                    "chat": true,
                                                    "computer": true,
                                                    "explorer": true
                                        }
                            },
                            "games": [
                                        {
                                                    "id": "n6z0jerF",
                                                    "name": "Player 1 - Player 2",
                                                    "fen": "rnbqkbnr/pppp1ppp/8/4p3/4P3/8/PPPP1PPP/RNBQKBNR w KQkq - 0 2",
                                                    "players": [
                                                                {
                                                                            "name": "Player 1"
                                                                },
                                                                {
                                                                            "name": "Player 2"
                                                                }
                                                    ],
                                                    "lastMove": "e7e5",
                                                    "thinkTime": 0,
                                                    "status": "*"
                                        },
                                        {
                                                    "id": "03cTYZaY",
                                                    "name": "Player 3 - Player 4",
                                                    "fen": "rnbqkbnr/ppp1pppp/8/3p4/3P4/8/PPP1PPPP/RNBQKBNR w KQkq - 0 2",
                                                    "players": [
                                                                {
                                                                            "name": "Player 3"
                                                                },
                                                                {
                                                                            "name": "Player 4"
                                                                }
                                                    ],
                                                    "lastMove": "d7d5",
                                                    "thinkTime": 0,
                                                    "status": "*"
                                        }
                            ],
                            "isSubscribed": false
                }
                """.trimIndent()

            val mockEngine =
                MockEngine { request ->
                    // Verify request matches expected endpoint: POST broadcast/round/${broadcastRoundId}/edit
                    assertEquals("broadcast/round/$broadcastRoundId/edit", request.url.encodedPath.trimStart('/'))
                    assertEquals(HttpMethod.parse("POST"), request.method)

                    respond(
                        content = ByteReadChannel(mockResponse),
                        status = HttpStatusCode.fromValue(200),
                        headers = headersOf(HttpHeaders.ContentType, "application/json"),
                    )
                }

            // Create mock HttpClient with proper configuration
            val mockHttpClient =
                HttpClient(mockEngine) {
                    install(ContentNegotiation) {
                        json(
                            Json {
                                ignoreUnknownKeys = true
                                coerceInputValues = true
                                explicitNulls = false
                            },
                        )
                    }
                }

            // Create service with mocked client
            val testApiClient =
                BaseApiClient(
                    baseUrl = "https://lichess.org",
                    token = "test_token",
                    httpClient = mockHttpClient,
                )
            val testService = BroadcastsService(testApiClient)

            // Act
            val result = testService.broadcastRoundUpdate(broadcastRoundId = "mock", formData = emptyMap())

            // Assert
            assertTrue(result.isSuccess, "API call should succeed")
            val response = result.getOrNull()
            assertNotNull(response, "Response should not be null")
            // Verify field: round
            // Verify field: tour
            // Verify field: study

            // Cleanup
            testApiClient.close()
        }

    @Test
    fun testBroadcastroundreset() =
        runTest {
            val broadcastRoundId = "mock"
            // Arrange - Mock HTTP response
            val mockResponse =
                """
                {
                            "ok": true
                }
                """.trimIndent()

            val mockEngine =
                MockEngine { request ->
                    // Verify request matches expected endpoint: POST api/broadcast/round/${broadcastRoundId}/reset
                    assertEquals("api/broadcast/round/$broadcastRoundId/reset", request.url.encodedPath.trimStart('/'))
                    assertEquals(HttpMethod.parse("POST"), request.method)

                    respond(
                        content = ByteReadChannel(mockResponse),
                        status = HttpStatusCode.fromValue(200),
                        headers = headersOf(HttpHeaders.ContentType, "application/json"),
                    )
                }

            // Create mock HttpClient with proper configuration
            val mockHttpClient =
                HttpClient(mockEngine) {
                    install(ContentNegotiation) {
                        json(
                            Json {
                                ignoreUnknownKeys = true
                                coerceInputValues = true
                                explicitNulls = false
                            },
                        )
                    }
                }

            // Create service with mocked client
            val testApiClient =
                BaseApiClient(
                    baseUrl = "https://lichess.org",
                    token = "test_token",
                    httpClient = mockHttpClient,
                )
            val testService = BroadcastsService(testApiClient)

            // Act
            val result = testService.broadcastRoundReset(broadcastRoundId = "mock")

            // Assert
            assertTrue(result.isSuccess, "API call should succeed")
            val response = result.getOrNull()
            assertNotNull(response, "Response should not be null")
            // Verify field: ok

            // Cleanup
            testApiClient.close()
        }

    @Test
    fun testBroadcastpush() =
        runTest {
            val broadcastRoundId = "mock"
            // Arrange - Mock HTTP response
            val mockResponse =
                """
                {
                            "games": [
                                        {
                                                    "tags": {
                                                                "White": "Player 1",
                                                                "Black": "Player 2",
                                                                "Result": "*",
                                                                "Event": "Knight Invitational"
                                                    },
                                                    "moves": 2
                                        },
                                        {
                                                    "tags": {
                                                                "White": "Player 3",
                                                                "Black": "Player 4",
                                                                "Result": "*",
                                                                "Event": "Knight Invitational"
                                                    },
                                                    "moves": 2
                                        }
                            ]
                }
                """.trimIndent()

            val mockEngine =
                MockEngine { request ->
                    // Verify request matches expected endpoint: POST api/broadcast/round/${broadcastRoundId}/push
                    assertEquals("api/broadcast/round/$broadcastRoundId/push", request.url.encodedPath.trimStart('/'))
                    assertEquals(HttpMethod.parse("POST"), request.method)

                    respond(
                        content = ByteReadChannel(mockResponse),
                        status = HttpStatusCode.fromValue(200),
                        headers = headersOf(HttpHeaders.ContentType, "application/json"),
                    )
                }

            // Create mock HttpClient with proper configuration
            val mockHttpClient =
                HttpClient(mockEngine) {
                    install(ContentNegotiation) {
                        json(
                            Json {
                                ignoreUnknownKeys = true
                                coerceInputValues = true
                                explicitNulls = false
                            },
                        )
                    }
                }

            // Create service with mocked client
            val testApiClient =
                BaseApiClient(
                    baseUrl = "https://lichess.org",
                    token = "test_token",
                    httpClient = mockHttpClient,
                )
            val testService = BroadcastsService(testApiClient)

            // Act
            val result = testService.broadcastPush(broadcastRoundId = "mock", body = "mock")

            // Assert
            assertTrue(result.isSuccess, "API call should succeed")
            val response = result.getOrNull()
            assertNotNull(response, "Response should not be null")
            // Verify field: games

            // Cleanup
            testApiClient.close()
        }

    @Test
    fun testBroadcaststreamroundpgn() =
        runTest {
            val broadcastRoundId = "mock"
            // Arrange - Mock HTTP response
            val mockResponse =
                """
                "[Event \"All about the Sicilian Defense: Dragon Variation\"]\n[Site \"https://lichess.org/study/8c8bmUfy/qwnXMwVC\"]\n[Result \"*\"]\n[UTCDate \"2017.06.25\"]\n[UTCTime \"10:12:04\"]\n[Variant \"Standard\"]\n[ECO \"B76\"]\n[Opening \"Sicilian Defense: Dragon Variation, Yugoslav Attack, Panov Variation\"]\n[Annotator \"https://lichess.org/@/Francesco_Super\"]\n\n{ This chapter will go over the Dragon Variation, a very common variation used by Black and it is the most aggressive variation in the Sicilian defense. }\n1. e4 c5 2. Nf3 { Simple developing move to control the d4 square } { [%csl Gd4,Gc5][%cal Gf3d4,Gc5d4] } 2... d6 { [%cal Gd6e5] } (2... e6 3. d4 cxd4 4. Nxd4 Nf6 5. e5 (5. Nc3 { [%cal Ge4e5] }) 5... Qa5+) 3. d4 { Whites want the exchange of pawns } { [%cal Gc5d4] } 3... cxd4 { [%cal Gf3d4] } 4. Nxd4 { Whites are now ahead in development but blacks still have the two central pawns whereas whites only one. } { [%csl Ge7,Gd6,Ge4] } 4... Nf6 { Blacks are now developing their knight and threatening the e4 pawn } { [%csl Ge4][%cal Gf6e4] } 5. Nc3 { The e4 pawn is now protected by the c3 knight } { [%csl Ge4,Bc3][%cal Rf6e4,Bc3e4] } 5... g6 { This is the DRAGON VARIATION. g6 allows the dark-squared bishop to develop and move to g7, controlling the long dark-squared diagonal } { [%csl Gd4] } 6. Be3 { [%cal Gd1d2,Gf2f3,Ge1c1,Gg2g4,Gh2h4,Gg4g5] } (6. Be2 Bg7 7. O-O Nc6 8. Be3 { [%cal Ge3d4] } (8. f3 Nxe4 { [%cal Gg7d4,Gc6d4] } 9. Nxc6 Qb6+ { [%cal Gb6c6,Gb6g1] } 10. Kh1 Nxc3 { [%cal Gc3d1,Gc3e2] } 11. bxc3 bxc6 { [%cal Gc8a6] }) 8... O-O 9. Nb3 a6 { [%cal Gb7b5,Gb5b4,Ge2c4] }) 6... Bg7 (6... Ng4 { [%cal Gg4e3] } 7. Bb5+ { [%cal Gb5e8,Gb8d7,Gc8d7,Gd1g4] } 7... Nc6 8. Nxc6 bxc6 9. Bxc6+ { [%cal Gc6a8] }) 7. f3 { The key opening moves for White, who attempt to castle queenside , whereas f3 strengthens the pawn structure, connecting e4 to the h2 and g2, while White also plan pushing to g4 and possibly h4. } { [%csl Bf3,Be3][%cal Rg2g4,Rh2h4,Rg4g5] } 7... O-O (7... h5 { Is operating against g4. }) 8. Qd2 { [%csl Gh6,Gg7][%cal Ge1c1,Ga1d1,Re3h6,Rd2h6] } 8... Nc6 { [%csl Gc6,Gh6][%cal Gb8c6,Ge1c1,Ga7a6,Ge3h6] } 9. g4 (9. Bh6 { [%cal Ge3d4] } 9... Bxh6 10. Qxh6 Nxd4) 9... Be6 10. Nxe6 fxe6 { [%cal Gf8f1] } 11. O-O-O Ne5 12. Be2 { [%csl Gf3][%cal Re5f3,Bd1h1,Bg1d1] } 12... Qc7 { [%csl Gc4][%cal Ge5c4,Gc4e3,Gc4d2,Bf8c8,Yc7c3] } 13. h4 Nc4 *\n"
                """.trimIndent()

            val mockEngine =
                MockEngine { request ->
                    // Verify request matches expected endpoint: GET api/stream/broadcast/round/${broadcastRoundId}.pgn
                    assertEquals(
                        "api/stream/broadcast/round/$broadcastRoundId.pgn",
                        request.url.encodedPath.trimStart('/'),
                    )
                    assertEquals(HttpMethod.parse("GET"), request.method)

                    respond(
                        content = ByteReadChannel(mockResponse),
                        status = HttpStatusCode.fromValue(200),
                        headers = headersOf(HttpHeaders.ContentType, "application/x-chess-pgn"),
                    )
                }

            // Create mock HttpClient with proper configuration
            val mockHttpClient =
                HttpClient(mockEngine) {
                    install(ContentNegotiation) {
                        json(
                            Json {
                                ignoreUnknownKeys = true
                                coerceInputValues = true
                                explicitNulls = false
                            },
                        )
                    }
                }

            // Create service with mocked client
            val testApiClient =
                BaseApiClient(
                    baseUrl = "https://lichess.org",
                    token = "test_token",
                    httpClient = mockHttpClient,
                )
            val testService = BroadcastsService(testApiClient)

            // Act
            val result = testService.broadcastStreamRoundPgn(broadcastRoundId = "mock")

            // Assert
            assertTrue(result.isSuccess, "API call should succeed")
            val response = result.getOrNull()
            assertNotNull(response, "Response should not be null")
            // Add specific field assertions here

            // Cleanup
            testApiClient.close()
        }

    @Test
    fun testBroadcastroundpgn() =
        runTest {
            val broadcastRoundId = "mock"
            // Arrange - Mock HTTP response
            val mockResponse =
                """
                "[Event \"All about the Sicilian Defense: Dragon Variation\"]\n[Site \"https://lichess.org/study/8c8bmUfy/qwnXMwVC\"]\n[Result \"*\"]\n[UTCDate \"2017.06.25\"]\n[UTCTime \"10:12:04\"]\n[Variant \"Standard\"]\n[ECO \"B76\"]\n[Opening \"Sicilian Defense: Dragon Variation, Yugoslav Attack, Panov Variation\"]\n[Annotator \"https://lichess.org/@/Francesco_Super\"]\n\n{ This chapter will go over the Dragon Variation, a very common variation used by Black and it is the most aggressive variation in the Sicilian defense. }\n1. e4 c5 2. Nf3 { Simple developing move to control the d4 square } { [%csl Gd4,Gc5][%cal Gf3d4,Gc5d4] } 2... d6 { [%cal Gd6e5] } (2... e6 3. d4 cxd4 4. Nxd4 Nf6 5. e5 (5. Nc3 { [%cal Ge4e5] }) 5... Qa5+) 3. d4 { Whites want the exchange of pawns } { [%cal Gc5d4] } 3... cxd4 { [%cal Gf3d4] } 4. Nxd4 { Whites are now ahead in development but blacks still have the two central pawns whereas whites only one. } { [%csl Ge7,Gd6,Ge4] } 4... Nf6 { Blacks are now developing their knight and threatening the e4 pawn } { [%csl Ge4][%cal Gf6e4] } 5. Nc3 { The e4 pawn is now protected by the c3 knight } { [%csl Ge4,Bc3][%cal Rf6e4,Bc3e4] } 5... g6 { This is the DRAGON VARIATION. g6 allows the dark-squared bishop to develop and move to g7, controlling the long dark-squared diagonal } { [%csl Gd4] } 6. Be3 { [%cal Gd1d2,Gf2f3,Ge1c1,Gg2g4,Gh2h4,Gg4g5] } (6. Be2 Bg7 7. O-O Nc6 8. Be3 { [%cal Ge3d4] } (8. f3 Nxe4 { [%cal Gg7d4,Gc6d4] } 9. Nxc6 Qb6+ { [%cal Gb6c6,Gb6g1] } 10. Kh1 Nxc3 { [%cal Gc3d1,Gc3e2] } 11. bxc3 bxc6 { [%cal Gc8a6] }) 8... O-O 9. Nb3 a6 { [%cal Gb7b5,Gb5b4,Ge2c4] }) 6... Bg7 (6... Ng4 { [%cal Gg4e3] } 7. Bb5+ { [%cal Gb5e8,Gb8d7,Gc8d7,Gd1g4] } 7... Nc6 8. Nxc6 bxc6 9. Bxc6+ { [%cal Gc6a8] }) 7. f3 { The key opening moves for White, who attempt to castle queenside , whereas f3 strengthens the pawn structure, connecting e4 to the h2 and g2, while White also plan pushing to g4 and possibly h4. } { [%csl Bf3,Be3][%cal Rg2g4,Rh2h4,Rg4g5] } 7... O-O (7... h5 { Is operating against g4. }) 8. Qd2 { [%csl Gh6,Gg7][%cal Ge1c1,Ga1d1,Re3h6,Rd2h6] } 8... Nc6 { [%csl Gc6,Gh6][%cal Gb8c6,Ge1c1,Ga7a6,Ge3h6] } 9. g4 (9. Bh6 { [%cal Ge3d4] } 9... Bxh6 10. Qxh6 Nxd4) 9... Be6 10. Nxe6 fxe6 { [%cal Gf8f1] } 11. O-O-O Ne5 12. Be2 { [%csl Gf3][%cal Re5f3,Bd1h1,Bg1d1] } 12... Qc7 { [%csl Gc4][%cal Ge5c4,Gc4e3,Gc4d2,Bf8c8,Yc7c3] } 13. h4 Nc4 *\n"
                """.trimIndent()

            val mockEngine =
                MockEngine { request ->
                    // Verify request matches expected endpoint: GET api/broadcast/round/${broadcastRoundId}.pgn
                    assertEquals("api/broadcast/round/$broadcastRoundId.pgn", request.url.encodedPath.trimStart('/'))
                    assertEquals(HttpMethod.parse("GET"), request.method)

                    respond(
                        content = ByteReadChannel(mockResponse),
                        status = HttpStatusCode.fromValue(200),
                        headers = headersOf(HttpHeaders.ContentType, "application/x-chess-pgn"),
                    )
                }

            // Create mock HttpClient with proper configuration
            val mockHttpClient =
                HttpClient(mockEngine) {
                    install(ContentNegotiation) {
                        json(
                            Json {
                                ignoreUnknownKeys = true
                                coerceInputValues = true
                                explicitNulls = false
                            },
                        )
                    }
                }

            // Create service with mocked client
            val testApiClient =
                BaseApiClient(
                    baseUrl = "https://lichess.org",
                    token = "test_token",
                    httpClient = mockHttpClient,
                )
            val testService = BroadcastsService(testApiClient)

            // Act
            val result = testService.broadcastRoundPgn(broadcastRoundId = "mock")

            // Assert
            assertTrue(result.isSuccess, "API call should succeed")
            val response = result.getOrNull()
            assertNotNull(response, "Response should not be null")
            // Add specific field assertions here

            // Cleanup
            testApiClient.close()
        }

    @Test
    fun testBroadcastallroundspgn() =
        runTest {
            val broadcastTournamentId = "mock"
            // Arrange - Mock HTTP response
            val mockResponse =
                """
                "[Event \"All about the Sicilian Defense: Dragon Variation\"]\n[Site \"https://lichess.org/study/8c8bmUfy/qwnXMwVC\"]\n[Result \"*\"]\n[UTCDate \"2017.06.25\"]\n[UTCTime \"10:12:04\"]\n[Variant \"Standard\"]\n[ECO \"B76\"]\n[Opening \"Sicilian Defense: Dragon Variation, Yugoslav Attack, Panov Variation\"]\n[Annotator \"https://lichess.org/@/Francesco_Super\"]\n\n{ This chapter will go over the Dragon Variation, a very common variation used by Black and it is the most aggressive variation in the Sicilian defense. }\n1. e4 c5 2. Nf3 { Simple developing move to control the d4 square } { [%csl Gd4,Gc5][%cal Gf3d4,Gc5d4] } 2... d6 { [%cal Gd6e5] } (2... e6 3. d4 cxd4 4. Nxd4 Nf6 5. e5 (5. Nc3 { [%cal Ge4e5] }) 5... Qa5+) 3. d4 { Whites want the exchange of pawns } { [%cal Gc5d4] } 3... cxd4 { [%cal Gf3d4] } 4. Nxd4 { Whites are now ahead in development but blacks still have the two central pawns whereas whites only one. } { [%csl Ge7,Gd6,Ge4] } 4... Nf6 { Blacks are now developing their knight and threatening the e4 pawn } { [%csl Ge4][%cal Gf6e4] } 5. Nc3 { The e4 pawn is now protected by the c3 knight } { [%csl Ge4,Bc3][%cal Rf6e4,Bc3e4] } 5... g6 { This is the DRAGON VARIATION. g6 allows the dark-squared bishop to develop and move to g7, controlling the long dark-squared diagonal } { [%csl Gd4] } 6. Be3 { [%cal Gd1d2,Gf2f3,Ge1c1,Gg2g4,Gh2h4,Gg4g5] } (6. Be2 Bg7 7. O-O Nc6 8. Be3 { [%cal Ge3d4] } (8. f3 Nxe4 { [%cal Gg7d4,Gc6d4] } 9. Nxc6 Qb6+ { [%cal Gb6c6,Gb6g1] } 10. Kh1 Nxc3 { [%cal Gc3d1,Gc3e2] } 11. bxc3 bxc6 { [%cal Gc8a6] }) 8... O-O 9. Nb3 a6 { [%cal Gb7b5,Gb5b4,Ge2c4] }) 6... Bg7 (6... Ng4 { [%cal Gg4e3] } 7. Bb5+ { [%cal Gb5e8,Gb8d7,Gc8d7,Gd1g4] } 7... Nc6 8. Nxc6 bxc6 9. Bxc6+ { [%cal Gc6a8] }) 7. f3 { The key opening moves for White, who attempt to castle queenside , whereas f3 strengthens the pawn structure, connecting e4 to the h2 and g2, while White also plan pushing to g4 and possibly h4. } { [%csl Bf3,Be3][%cal Rg2g4,Rh2h4,Rg4g5] } 7... O-O (7... h5 { Is operating against g4. }) 8. Qd2 { [%csl Gh6,Gg7][%cal Ge1c1,Ga1d1,Re3h6,Rd2h6] } 8... Nc6 { [%csl Gc6,Gh6][%cal Gb8c6,Ge1c1,Ga7a6,Ge3h6] } 9. g4 (9. Bh6 { [%cal Ge3d4] } 9... Bxh6 10. Qxh6 Nxd4) 9... Be6 10. Nxe6 fxe6 { [%cal Gf8f1] } 11. O-O-O Ne5 12. Be2 { [%csl Gf3][%cal Re5f3,Bd1h1,Bg1d1] } 12... Qc7 { [%csl Gc4][%cal Ge5c4,Gc4e3,Gc4d2,Bf8c8,Yc7c3] } 13. h4 Nc4 *\n"
                """.trimIndent()

            val mockEngine =
                MockEngine { request ->
                    // Verify request matches expected endpoint: GET api/broadcast/${broadcastTournamentId}.pgn
                    assertEquals("api/broadcast/$broadcastTournamentId.pgn", request.url.encodedPath.trimStart('/'))
                    assertEquals(HttpMethod.parse("GET"), request.method)

                    respond(
                        content = ByteReadChannel(mockResponse),
                        status = HttpStatusCode.fromValue(200),
                        headers = headersOf(HttpHeaders.ContentType, "application/x-chess-pgn"),
                    )
                }

            // Create mock HttpClient with proper configuration
            val mockHttpClient =
                HttpClient(mockEngine) {
                    install(ContentNegotiation) {
                        json(
                            Json {
                                ignoreUnknownKeys = true
                                coerceInputValues = true
                                explicitNulls = false
                            },
                        )
                    }
                }

            // Create service with mocked client
            val testApiClient =
                BaseApiClient(
                    baseUrl = "https://lichess.org",
                    token = "test_token",
                    httpClient = mockHttpClient,
                )
            val testService = BroadcastsService(testApiClient)

            // Act
            val result = testService.broadcastAllRoundsPgn(broadcastTournamentId = "mock")

            // Assert
            assertTrue(result.isSuccess, "API call should succeed")
            val response = result.getOrNull()
            assertNotNull(response, "Response should not be null")
            // Add specific field assertions here

            // Cleanup
            testApiClient.close()
        }

    @Test
    fun testBroadcastmyroundsget() =
        runTest {
            // Arrange - Mock HTTP response
            val mockResponse =
                """
                {
                            "round": {
                                        "id": "UpDXGrhz",
                                        "name": "Final Round 2",
                                        "slug": "final-round-2",
                                        "createdAt": 1760452032086,
                                        "rated": false,
                                        "ongoing": true,
                                        "startsAt": 1760452032087,
                                        "url": "https://lichess.org/broadcast/knight-invitational-2/final-round-2/UpDXGrhz"
                            },
                            "tour": {
                                        "id": "dkGBWEoa",
                                        "name": "Knight Invitational 2",
                                        "slug": "knight-invitational-2",
                                        "info": {},
                                        "createdAt": 1760452031769,
                                        "url": "https://lichess.org/broadcast/knight-invitational-2/dkGBWEoa",
                                        "dates": [
                                                    1760452032087
                                        ]
                            },
                            "study": {
                                        "writeable": true,
                                        "features": {
                                                    "chat": true,
                                                    "computer": true,
                                                    "explorer": true
                                        }
                            }
                }
                """.trimIndent()

            val mockEngine =
                MockEngine { request ->
                    // Verify request matches expected endpoint: GET api/broadcast/my-rounds
                    assertEquals("api/broadcast/my-rounds", request.url.encodedPath.trimStart('/'))
                    assertEquals(HttpMethod.parse("GET"), request.method)

                    respond(
                        content = ByteReadChannel(mockResponse),
                        status = HttpStatusCode.fromValue(200),
                        headers = headersOf(HttpHeaders.ContentType, "application/x-ndjson"),
                    )
                }

            // Create mock HttpClient with proper configuration
            val mockHttpClient =
                HttpClient(mockEngine) {
                    install(ContentNegotiation) {
                        json(
                            Json {
                                ignoreUnknownKeys = true
                                coerceInputValues = true
                                explicitNulls = false
                            },
                        )
                    }
                }

            // Create service with mocked client
            val testApiClient =
                BaseApiClient(
                    baseUrl = "https://lichess.org",
                    token = "test_token",
                    httpClient = mockHttpClient,
                )
            val testService = BroadcastsService(testApiClient)

            // Act
            val result = testService.broadcastMyRoundsGet()

            // Assert
            assertTrue(result.isSuccess, "API call should succeed")
            val response = result.getOrNull()
            assertNotNull(response, "Response should not be null")
            // Verify field: round
            // Verify field: tour
            // Verify field: study

            // Cleanup
            testApiClient.close()
        }
}
